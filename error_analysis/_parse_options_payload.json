{
    "errors": {
        "memcmp": [
            "memcmp @ Line 19: memcmp region 1 readable",
            "memcmp @ Line 27: dereference failure: pointer NULL in *tmp_post_sc1"
        ],
        "ipv6_addr_set_aiid": [
            "ipv6_addr_set_aiid @ Line 630: memcpy destination region writeable"
        ],
        "_parse_options": [
            "_parse_options @ Line 533: dereference failure: dead object in opt->type",
            "_parse_options @ Line 551: dereference failure: pointer NULL in dc->ocp",
            "_parse_options @ Line 559: dereference failure: pointer NULL in dc->dio_int_doubl",
            "_parse_options @ Line 560: dereference failure: pointer NULL in dc->dio_int_min",
            "_parse_options @ Line 561: dereference failure: pointer NULL in dc->dio_redun",
            "_parse_options @ Line 562: dereference failure: dead object in dc->max_rank_inc",
            "_parse_options @ Line 563: dereference failure: pointer NULL in dc->min_hop_rank_inc",
            "_parse_options @ Line 564: dereference failure: pointer NULL in dc->default_lifetime",
            "_parse_options @ Line 565: dereference failure: pointer NULL in dc->lifetime_unit",
            "_parse_options @ Line 591: dereference failure: pointer NULL in pi->LAR_flags",
            "_parse_options @ Line 596: dereference failure: pointer NULL in pi->prefix_len",
            "_parse_options @ Line 599: dereference failure: pointer NULL in pi->prefix_len",
            "_parse_options @ Line 600: dereference failure: pointer NULL in pi->valid_lifetime",
            "_parse_options @ Line 601: dereference failure: pointer NULL in pi->pref_lifetime",
            "_parse_options @ Line 610: dereference failure: pointer NULL in sol->length",
            "_parse_options @ Line 616: dereference failure: pointer NULL in sol->VID_flags",
            "_parse_options @ Line 617: dereference failure: pointer NULL in sol->version_number",
            "_parse_options @ Line 623: dereference failure: pointer NULL in sol->VID_flags",
            "_parse_options @ Line 624: dereference failure: pointer NULL in sol->instance_id",
            "_parse_options @ Line 630: dereference failure: pointer NULL in sol->VID_flags",
            "_parse_options @ Line 650: dereference failure: pointer NULL in target->prefix_length",
            "_parse_options @ Line 651: dereference failure: pointer NULL in target->prefix_length",
            "_parse_options @ Line 692: dereference failure: pointer NULL in opt->length"
        ],
        "gnrc_rpl_validation_options": [
            "gnrc_rpl_validation_options @ Line 32: dereference failure: pointer NULL in opt->type",
            "gnrc_rpl_validation_options @ Line 42: dereference failure: dead object in opt->type",
            "gnrc_rpl_validation_options @ Line 49: dereference failure: pointer NULL in opt->length",
            "gnrc_rpl_validation_options @ Line 62: dereference failure: pointer NULL in opt->length",
            "gnrc_rpl_validation_options @ Line 75: dereference failure: pointer NULL in opt->length",
            "gnrc_rpl_validation_options @ Line 94: dereference failure: pointer NULL in opt->length",
            "gnrc_rpl_validation_options @ Line 105: dereference failure: pointer NULL in opt->length"
        ]
    },
    "unit_proof": "42 void harness(void)\n43 {\n44\n45     int msg_type;\n46     gnrc_rpl_instance_t inst;\n47\n48     uint16_t opt_len;\n49\n50\n51\n52     gnrc_rpl_opt_t* opt = malloc(opt_len);\n53\n54\n55\n56\n57\n58\n59\n60     ipv6_addr_t src;\n61     uint32_t included_opts;\n62\n63     _parse_options(msg_type, &inst, opt, opt_len, &src, &included_opts);\n64 }\n",
    "relevent_funcs": {
        "_parse_options": "515 bool _parse_options(int msg_type, gnrc_rpl_instance_t *inst, gnrc_rpl_opt_t *opt,\n516                            uint16_t len,\n517                            ipv6_addr_t *src, uint32_t *included_opts)\n518 {\n519     uint16_t len_parsed = 0;\n520     gnrc_rpl_opt_target_t *first_target = NULL;\n521     gnrc_rpl_dodag_t *dodag = &inst->dodag;\n522     eui64_t iid;\n523\n524     *included_opts = 0;\n525\n526     if (!IS_ACTIVE(CONFIG_GNRC_RPL_WITHOUT_VALIDATION)) {\n527         if (!gnrc_rpl_validation_options(msg_type, inst, opt, len)) {\n528             return false;\n529         }\n530     }\n531\n532     while (len_parsed < len) {\n533         switch (opt->type) {\n534         case (GNRC_RPL_OPT_PAD1):\n535             DEBUG(\"RPL: PAD1 option parsed\\n\");\n536             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_PAD1;\n537             len_parsed += 1;\n538             opt = (gnrc_rpl_opt_t *)(((uint8_t *)opt) + 1);\n539             continue;\n540\n541         case (GNRC_RPL_OPT_PADN):\n542             DEBUG(\"RPL: PADN option parsed\\n\");\n543             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_PADN;\n544             break;\n545\n546         case (GNRC_RPL_OPT_DODAG_CONF):\n547             DEBUG(\"RPL: DODAG CONF DIO option parsed\\n\");\n548             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_DODAG_CONF;\n549             dodag->dio_opts |= GNRC_RPL_REQ_DIO_OPT_DODAG_CONF;\n550             gnrc_rpl_opt_dodag_conf_t *dc = (gnrc_rpl_opt_dodag_conf_t *)opt;\n551             gnrc_rpl_of_t *of = gnrc_rpl_get_of_for_ocp(byteorder_ntohs(dc->ocp));\n552             if (of != NULL) {\n553                 inst->of = of;\n554             }\n555             else {\n556                 DEBUG(\"RPL: Unsupported OCP 0x%02x\\n\", byteorder_ntohs(dc->ocp));\n557                 inst->of = gnrc_rpl_get_of_for_ocp(GNRC_RPL_DEFAULT_OCP);\n558             }\n559             dodag->dio_interval_doubl = dc->dio_int_doubl;\n560             dodag->dio_min = dc->dio_int_min;\n561             dodag->dio_redun = dc->dio_redun;\n562             inst->max_rank_inc = byteorder_ntohs(dc->max_rank_inc);\n563             inst->min_hop_rank_inc = byteorder_ntohs(dc->min_hop_rank_inc);\n564             dodag->default_lifetime = dc->default_lifetime;\n565             dodag->lifetime_unit = byteorder_ntohs(dc->lifetime_unit);\n566\n567\n568\n569\n570\n571\n572             dodag->trickle.Imin = (1 << (dodag->dio_min >= 31 ? 30 : dodag->dio_min));\n573             dodag->trickle.Imax = dodag->dio_interval_doubl;\n574             dodag->trickle.k = dodag->dio_redun;\n575             break;\n576\n577         case (GNRC_RPL_OPT_PREFIX_INFO):\n578             DEBUG(\"RPL: Prefix Information DIO option parsed\\n\");\n579             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_PREFIX_INFO;\n580\n581             if (!IS_ACTIVE(CONFIG_GNRC_RPL_WITHOUT_PIO)) {\n582                 dodag->dio_opts |= GNRC_RPL_REQ_DIO_OPT_PREFIX_INFO;\n583             }\n584\n585             gnrc_rpl_opt_prefix_info_t *pi = (gnrc_rpl_opt_prefix_info_t *)opt;\n586             /* check for the auto address-configuration flag */\n587             gnrc_netif_t *netif = gnrc_netif_get_by_pid(dodag->iface);\n588\n589             assert(netif != NULL);\n590             if ((gnrc_netif_ipv6_get_iid(netif, &iid) < 0)\n591                 && !(pi->LAR_flags & GNRC_RPL_PREFIX_AUTO_ADDRESS_BIT)) {\n592                 break;\n593             }\n594             ipv6_addr_set_aiid(&pi->prefix, iid.uint8);\n595             /* TODO: find a way to do this with DAD (i.e. state != VALID) */\n596             gnrc_netif_ipv6_addr_add_internal(netif, &pi->prefix, pi->prefix_len,\n597                                               GNRC_NETIF_IPV6_ADDRS_FLAGS_STATE_VALID);\n598             /* set lifetimes */\n599             gnrc_ipv6_nib_pl_set(netif->pid, &pi->prefix, pi->prefix_len,\n600                                  _sec_to_ms(byteorder_ntohl(pi->valid_lifetime)),\n601                                  _sec_to_ms(byteorder_ntohl(pi->pref_lifetime)));\n602\n603             break;\n604         case (GNRC_RPL_OPT_SOLICITED_INFO):\n605             DEBUG(\"RPL: RPL SOLICITED INFO option parsed\\n\");\n606             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_SOLICITED_INFO;\n607             gnrc_rpl_opt_dis_solicited_t *sol = (gnrc_rpl_opt_dis_solicited_t *)opt;\n608\n609             /* check expected length */\n610             if (sol->length != GNRC_RPL_DIS_SOLICITED_INFO_LENGTH) {\n611                 DEBUG(\"RPL: RPL SOLICITED INFO option, unexpected length: %d\\n\", sol->length);\n612                 return false;\n613             }\n614\n615             /* check the DODAG Version */\n616             if ((sol->VID_flags & GNRC_RPL_DIS_SOLICITED_INFO_FLAG_V)\n617                 && (sol->version_number != inst->dodag.version)) {\n618                 DEBUG(\"RPL: RPL SOLICITED INFO option, ignore DIS cause: DODAG Version mismatch\\n\");\n619                 return false;\n620             }\n621\n622             /* check the Instance ID */\n623             if ((sol->VID_flags & GNRC_RPL_DIS_SOLICITED_INFO_FLAG_I)\n624                 && (sol->instance_id != inst->id)) {\n625                 DEBUG(\"RPL: RPL SOLICITED INFO option, ignore DIS cause: InstanceID mismatch\\n\");\n626                 return false;\n627             }\n628\n629             /* check the DODAG ID */\n630             if (sol->VID_flags & GNRC_RPL_DIS_SOLICITED_INFO_FLAG_D) {\n631                 if (memcmp(&sol->dodag_id, &inst->dodag.dodag_id, sizeof(ipv6_addr_t)) != 0) {\n632                     DEBUG(\"RPL: RPL SOLICITED INFO option, ignore DIS cause: DODAGID mismatch\\n\");\n633                     return false;\n634                 }\n635             }\n636             break;\n637         case (GNRC_RPL_OPT_TARGET):\n638             DEBUG(\"RPL: RPL TARGET DAO option parsed\\n\");\n639             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_TARGET;\n640\n641             gnrc_rpl_opt_target_t *target = (gnrc_rpl_opt_target_t *)opt;\n642             if (first_target == NULL) {\n643                 first_target = target;\n644             }\n645\n646             DEBUG(\"RPL: adding FT entry %s/%d\\n\",\n647                   ipv6_addr_to_str(addr_str, &(target->target), (unsigned)sizeof(addr_str)),\n648                   target->prefix_length);\n649\n650             gnrc_ipv6_nib_ft_del(&(target->target), target->prefix_length);\n651             gnrc_ipv6_nib_ft_add(&(target->target), target->prefix_length, src,\n652                                  dodag->iface,\n653                                  dodag->default_lifetime * dodag->lifetime_unit);\n654             break;\n655\n656         case (GNRC_RPL_OPT_TRANSIT):\n657             DEBUG(\"RPL: RPL TRANSIT INFO DAO option parsed\\n\");\n658             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_TRANSIT;\n659             gnrc_rpl_opt_transit_t *transit = (gnrc_rpl_opt_transit_t *)opt;\n660             if (first_target == NULL) {\n661                 DEBUG(\"RPL: Encountered a RPL TRANSIT DAO option without \"\n662                       \"a preceding RPL TARGET DAO option\\n\");\n663                 break;\n664             }\n665\n666             do {\n667                 DEBUG(\"RPL: updating FT entry %s/%d\\n\",\n668                       ipv6_addr_to_str(addr_str, &(first_target->target), sizeof(addr_str)),\n669                       first_target->prefix_length);\n670\n671                 gnrc_ipv6_nib_ft_del(&(first_target->target),\n672                                      first_target->prefix_length);\n673                 gnrc_ipv6_nib_ft_add(&(first_target->target),\n674                                      first_target->prefix_length, src,\n675                                      dodag->iface,\n676                                      transit->path_lifetime * dodag->lifetime_unit);\n677\n678                 first_target = (gnrc_rpl_opt_target_t *)(((uint8_t *)(first_target)) +\n679                                                          sizeof(gnrc_rpl_opt_t) +\n680                                                          first_target->length);\n681             }while (first_target->type == GNRC_RPL_OPT_TARGET);\n682\n683             first_target = NULL;\n684             break;\n685\n686 #ifdef MODULE_GNRC_RPL_P2P\n687         case (GNRC_RPL_P2P_OPT_RDO):\n688             gnrc_rpl_p2p_rdo_parse((gnrc_rpl_p2p_opt_rdo_t *)opt, gnrc_rpl_p2p_ext_get(dodag));\n689             break;\n690 #endif\n691         }\n692         len_parsed += opt->length + sizeof(gnrc_rpl_opt_t);\n693         opt = (gnrc_rpl_opt_t *)(((uint8_t *)(opt + 1)) + opt->length);\n694     }\n695     return true;\n696 }\n",
        "gnrc_rpl_validation_options": "26 bool gnrc_rpl_validation_options(int msg_type, gnrc_rpl_instance_t *inst,\n27                                  gnrc_rpl_opt_t *opt, uint16_t len)\n28 {\n29     uint16_t expected_len = 0;\n30\n31     while(expected_len < len) {\n32         if (opt->type == GNRC_RPL_OPT_PAD1) {\n33             expected_len += 1;\n34             opt = (gnrc_rpl_opt_t *) (((uint8_t *) opt) + 1);\n35             continue;\n36         }\n37\n38         if ((expected_len + sizeof(gnrc_rpl_opt_t)) > len) {\n39             break;\n40         }\n41\n42         switch(opt->type) {\n43             case (GNRC_RPL_OPT_DODAG_CONF):\n44                 if (msg_type != GNRC_RPL_ICMPV6_CODE_DIO) {\n45                     DEBUG(\"RPL: DODAG CONF DIO option not expected\\n\");\n46                     return false;\n47                 }\n48\n49                 if (opt->length != GNRC_RPL_OPT_DODAG_CONF_LEN) {\n50                     DEBUG(\"RPL: wrong DIO option (DODAG CONF) len: %d, expected: %d\\n\",\n51                            opt->length, GNRC_RPL_OPT_DODAG_CONF_LEN);\n52                     return false;\n53                 }\n54                 break;\n55\n56             case (GNRC_RPL_OPT_PREFIX_INFO):\n57                 if (msg_type != GNRC_RPL_ICMPV6_CODE_DIO) {\n58                     DEBUG(\"RPL: PREFIX INFO DIO option not expected\\n\");\n59                     return false;\n60                 }\n61\n62                 if (opt->length != GNRC_RPL_OPT_PREFIX_INFO_LEN) {\n63                     DEBUG(\"RPL: wrong DIO option (PREFIX INFO) len: %d, expected: %d\\n\",\n64                            opt->length, GNRC_RPL_OPT_PREFIX_INFO_LEN);\n65                     return false;\n66                 }\n67                 break;\n68\n69             case (GNRC_RPL_OPT_TARGET):\n70                 if (msg_type != GNRC_RPL_ICMPV6_CODE_DAO) {\n71                     DEBUG(\"RPL: RPL TARGET DAO option not expected\\n\");\n72                     return false;\n73                 }\n74\n75                 if (opt->length != GNRC_RPL_OPT_TARGET_LEN) {\n76\n77                     DEBUG(\"RPL: wrong DAO option (RPL TARGET) len: %d, expected (max): %d\\n\",\n78                            opt->length, GNRC_RPL_OPT_TARGET_LEN);\n79                     return false;\n80                 }\n81                 break;\n82\n83             case (GNRC_RPL_OPT_TRANSIT):\n84                 if (msg_type != GNRC_RPL_ICMPV6_CODE_DAO) {\n85                     DEBUG(\"RPL: RPL TRANSIT INFO DAO option not expected\\n\");\n86                     return false;\n87                 }\n88\n89                 uint8_t parent_addr = 0;\n90                 if (inst->mop == GNRC_RPL_MOP_NON_STORING_MODE) {\n91                     parent_addr = sizeof(ipv6_addr_t);\n92                 }\n93\n94                 if (opt->length != (GNRC_RPL_OPT_TRANSIT_INFO_LEN + parent_addr)) {\n95                     DEBUG(\"RPL: wrong DAO option (TRANSIT INFO) len: %d, expected: %d\\n\",\n96                            opt->length, (GNRC_RPL_OPT_TRANSIT_INFO_LEN + parent_addr));\n97                     return false;\n98                 }\n99                 break;\n100\n101             default:\n102                 break;\n103\n104         }\n105         expected_len += opt->length + sizeof(gnrc_rpl_opt_t);\n106\n107         if (expected_len >= len) {\n108           break;\n109         }\n110\n111         opt = (gnrc_rpl_opt_t *) (((uint8_t *) (opt + 1)) + opt->length);\n112     }\n113\n114     if (expected_len == len) {\n115         return true;\n116     }\n117\n118     DEBUG(\"RPL: wrong options len: %d, expected: %d\\n\", len, expected_len);\n119\n120     return false;\n121 }\n122\n123 /**\n124  * @}\n",
        "gnrc_netif_get_by_pid": "32 gnrc_netif_t *gnrc_netif_get_by_pid(kernel_pid_t pid) {\n33     //Normally this function can return NULL\n34     //But _parse_options has an assert that checks for this\n35     //So in the stub I'll assume it can't return NULL\n36     gnrc_netif_t *new_netif = malloc(sizeof(gnrc_netif_t));\n37     __CPROVER_assume(new_netif != NULL);\n38     return new_netif;\n39\n40 }\n41\n42 void harness(void)\n43 {\n44\n45     int msg_type;\n46     gnrc_rpl_instance_t inst;\n47\n48     uint16_t opt_len;\n49\n50\n51\n52     gnrc_rpl_opt_t* opt = malloc(opt_len);\n53\n54\n55\n56\n57\n58\n59\n60     ipv6_addr_t src;\n61     uint32_t included_opts;\n62\n63     _parse_options(msg_type, &inst, opt, opt_len, &src, &included_opts);\n64 }\n",
        "gnrc_netif_ipv6_get_iid": "643 static inline int gnrc_netif_ipv6_get_iid(gnrc_netif_t *netif, eui64_t *iid)\n644 {\n645 #if GNRC_NETIF_L2ADDR_MAXLEN > 0\n646     if (netif->flags & GNRC_NETIF_FLAGS_HAS_L2ADDR) {\n647         return gnrc_netif_ipv6_iid_from_addr(netif,\n648                                              netif->l2addr, netif->l2addr_len,\n649                                              iid);\n650     }\n651 #endif /* GNRC_NETIF_L2ADDR_MAXLEN > 0 */\n652     (void)netif;\n653     (void)iid;\n654     return -ENOTSUP;\n655 }\n",
        "ipv6_addr_set_aiid": "628 static inline void ipv6_addr_set_aiid(ipv6_addr_t *addr, uint8_t *iid)\n629 {\n630     memcpy(&addr->u64[1], iid, sizeof(addr->u64[1]));\n631 }\n",
        "byteorder_ntohs": "230 static inline uint16_t byteorder_ntohs(network_uint16_t v);\n",
        "byteorder_ntohl": "237 static inline uint32_t byteorder_ntohl(network_uint32_t v);\n",
        "_sec_to_ms": "499 static inline uint32_t _sec_to_ms(uint32_t sec)\n500 {\n501     if (sec == UINT32_MAX) {\n502         /* infinite stays infinite */\n503         return UINT32_MAX;\n504     }\n505     else if (sec > ((UINT32_MAX - 1) / MS_PER_SEC)) {\n506         /* truncate long intervals to largest possible value */\n507         return UINT32_MAX - 1;\n508     }\n509     else {\n510         return sec * MS_PER_SEC;\n511     }\n512 }\n"
    }
}