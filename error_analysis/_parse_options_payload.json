{
    "errors": {
        "ipv6_addr_set_aiid": [
            "ipv6_addr_set_aiid @ Line 630: memcpy destination region writeable"
        ],
        "_parse_options": [
            "_parse_options @ Line 553: dereference failure: pointer outside object bounds in dc->ocp",
            "_parse_options @ Line 561: dereference failure: pointer outside object bounds in dc->dio_int_doubl",
            "_parse_options @ Line 562: dereference failure: pointer outside object bounds in dc->dio_int_min",
            "_parse_options @ Line 563: dereference failure: pointer outside object bounds in dc->dio_redun",
            "_parse_options @ Line 564: dereference failure: pointer outside object bounds in dc->max_rank_inc",
            "_parse_options @ Line 565: dereference failure: pointer outside object bounds in dc->min_hop_rank_inc",
            "_parse_options @ Line 566: dereference failure: pointer outside object bounds in dc->default_lifetime",
            "_parse_options @ Line 567: dereference failure: pointer outside object bounds in dc->lifetime_unit",
            "_parse_options @ Line 593: dereference failure: pointer outside object bounds in pi->LAR_flags",
            "_parse_options @ Line 602: dereference failure: pointer outside object bounds in pi->valid_lifetime",
            "_parse_options @ Line 603: dereference failure: pointer outside object bounds in pi->pref_lifetime",
            "_parse_options @ Line 652: dereference failure: pointer outside object bounds in target->prefix_length",
            "_parse_options @ Line 653: dereference failure: pointer outside object bounds in target->prefix_length"
        ]
    },
    "unit_proof": "42 void harness(void)\n43 {\n44\n45     int msg_type;\n46     gnrc_rpl_instance_t inst;\n47\n48     uint16_t opt_len;\n49     __CPROVER_assume(opt_len > sizeof(gnrc_rpl_opt_t));\n50\n51\n52     gnrc_rpl_opt_t* opt = malloc(opt_len);\n53     __CPROVER_assume(opt != NULL);\n54\n55\n56\n57     __CPROVER_assume(opt -> length <= opt_len - sizeof(gnrc_rpl_opt_t));\n58\n59\n60     ipv6_addr_t src;\n61     uint32_t included_opts;\n62\n63     _parse_options(msg_type, &inst, opt, opt_len, &src, &included_opts);\n64 }\n",
    "stubs": {
        "gnrc_netif_get_by_pid": "32 gnrc_netif_t *gnrc_netif_get_by_pid(kernel_pid_t pid) {\n33     //Normally this function can return NULL\n34     //But _parse_options has an assert that checks for this\n35     //So in the stub I'll assume it can't return NULL\n36     gnrc_netif_t *new_netif = malloc(sizeof(gnrc_netif_t));\n37     __CPROVER_assume(new_netif != NULL);\n38     return new_netif;\n39\n40 }\n41\n42 void harness(void)\n43 {\n44\n45     int msg_type;\n46     gnrc_rpl_instance_t inst;\n47\n48     uint16_t opt_len;\n49     __CPROVER_assume(opt_len > sizeof(gnrc_rpl_opt_t));\n50\n51\n52     gnrc_rpl_opt_t* opt = malloc(opt_len);\n53     __CPROVER_assume(opt != NULL);\n54\n55\n56\n57     __CPROVER_assume(opt -> length <= opt_len - sizeof(gnrc_rpl_opt_t));\n58\n59\n60     ipv6_addr_t src;\n61     uint32_t included_opts;\n62\n63     _parse_options(msg_type, &inst, opt, opt_len, &src, &included_opts);\n64 }\n"
    },
    "relevent_funcs": {
        "_parse_options": "517 bool _parse_options(int msg_type, gnrc_rpl_instance_t *inst, gnrc_rpl_opt_t *opt,\n518                            uint16_t len,\n519                            ipv6_addr_t *src, uint32_t *included_opts)\n520 {\n521     uint16_t len_parsed = 0;\n522     gnrc_rpl_opt_target_t *first_target = NULL;\n523     gnrc_rpl_dodag_t *dodag = &inst->dodag;\n524     eui64_t iid;\n525\n526     *included_opts = 0;\n527\n528     if (!IS_ACTIVE(CONFIG_GNRC_RPL_WITHOUT_VALIDATION)) {\n529         if (!gnrc_rpl_validation_options(msg_type, inst, opt, len)) {\n530             return false;\n531         }\n532     }\n533\n534     while (len_parsed < len) {\n535         switch (opt->type) {\n536         case (GNRC_RPL_OPT_PAD1):\n537             DEBUG(\"RPL: PAD1 option parsed\\n\");\n538             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_PAD1;\n539             len_parsed += 1;\n540             opt = (gnrc_rpl_opt_t *)(((uint8_t *)opt) + 1);\n541             continue;\n542\n543         case (GNRC_RPL_OPT_PADN):\n544             DEBUG(\"RPL: PADN option parsed\\n\");\n545             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_PADN;\n546             break;\n547\n548         case (GNRC_RPL_OPT_DODAG_CONF):\n549             DEBUG(\"RPL: DODAG CONF DIO option parsed\\n\");\n550             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_DODAG_CONF;\n551             dodag->dio_opts |= GNRC_RPL_REQ_DIO_OPT_DODAG_CONF;\n552             gnrc_rpl_opt_dodag_conf_t *dc = (gnrc_rpl_opt_dodag_conf_t *)opt;\n553             gnrc_rpl_of_t *of = gnrc_rpl_get_of_for_ocp(byteorder_ntohs(dc->ocp));\n554             if (of != NULL) {\n555                 inst->of = of;\n556             }\n557             else {\n558                 DEBUG(\"RPL: Unsupported OCP 0x%02x\\n\", byteorder_ntohs(dc->ocp));\n559                 inst->of = gnrc_rpl_get_of_for_ocp(GNRC_RPL_DEFAULT_OCP);\n560             }\n561             dodag->dio_interval_doubl = dc->dio_int_doubl;\n562             dodag->dio_min = dc->dio_int_min;\n563             dodag->dio_redun = dc->dio_redun;\n564             inst->max_rank_inc = byteorder_ntohs(dc->max_rank_inc);\n565             inst->min_hop_rank_inc = byteorder_ntohs(dc->min_hop_rank_inc);\n566             dodag->default_lifetime = dc->default_lifetime;\n567             dodag->lifetime_unit = byteorder_ntohs(dc->lifetime_unit);\n568\n569\n570\n571\n572\n573\n574             dodag->trickle.Imin = (1 << (dodag->dio_min >= 31 ? 30 : dodag->dio_min));\n575             dodag->trickle.Imax = dodag->dio_interval_doubl;\n576             dodag->trickle.k = dodag->dio_redun;\n577             break;\n578\n579         case (GNRC_RPL_OPT_PREFIX_INFO):\n580             DEBUG(\"RPL: Prefix Information DIO option parsed\\n\");\n581             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_PREFIX_INFO;\n582\n583             if (!IS_ACTIVE(CONFIG_GNRC_RPL_WITHOUT_PIO)) {\n584                 dodag->dio_opts |= GNRC_RPL_REQ_DIO_OPT_PREFIX_INFO;\n585             }\n586\n587             gnrc_rpl_opt_prefix_info_t *pi = (gnrc_rpl_opt_prefix_info_t *)opt;\n588             /* check for the auto address-configuration flag */\n589             gnrc_netif_t *netif = gnrc_netif_get_by_pid(dodag->iface);\n590\n591             assert(netif != NULL);\n592             if ((gnrc_netif_ipv6_get_iid(netif, &iid) < 0)\n593                 && !(pi->LAR_flags & GNRC_RPL_PREFIX_AUTO_ADDRESS_BIT)) {\n594                 break;\n595             }\n596             ipv6_addr_set_aiid(&pi->prefix, iid.uint8);\n597             /* TODO: find a way to do this with DAD (i.e. state != VALID) */\n598             gnrc_netif_ipv6_addr_add_internal(netif, &pi->prefix, pi->prefix_len,\n599                                               GNRC_NETIF_IPV6_ADDRS_FLAGS_STATE_VALID);\n600             /* set lifetimes */\n601             gnrc_ipv6_nib_pl_set(netif->pid, &pi->prefix, pi->prefix_len,\n602                                  _sec_to_ms(byteorder_ntohl(pi->valid_lifetime)),\n603                                  _sec_to_ms(byteorder_ntohl(pi->pref_lifetime)));\n604\n605             break;\n606         case (GNRC_RPL_OPT_SOLICITED_INFO):\n607             DEBUG(\"RPL: RPL SOLICITED INFO option parsed\\n\");\n608             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_SOLICITED_INFO;\n609             gnrc_rpl_opt_dis_solicited_t *sol = (gnrc_rpl_opt_dis_solicited_t *)opt;\n610\n611             /* check expected length */\n612             if (sol->length != GNRC_RPL_DIS_SOLICITED_INFO_LENGTH) {\n613                 DEBUG(\"RPL: RPL SOLICITED INFO option, unexpected length: %d\\n\", sol->length);\n614                 return false;\n615             }\n616\n617             /* check the DODAG Version */\n618             if ((sol->VID_flags & GNRC_RPL_DIS_SOLICITED_INFO_FLAG_V)\n619                 && (sol->version_number != inst->dodag.version)) {\n620                 DEBUG(\"RPL: RPL SOLICITED INFO option, ignore DIS cause: DODAG Version mismatch\\n\");\n621                 return false;\n622             }\n623\n624             /* check the Instance ID */\n625             if ((sol->VID_flags & GNRC_RPL_DIS_SOLICITED_INFO_FLAG_I)\n626                 && (sol->instance_id != inst->id)) {\n627                 DEBUG(\"RPL: RPL SOLICITED INFO option, ignore DIS cause: InstanceID mismatch\\n\");\n628                 return false;\n629             }\n630\n631             /* check the DODAG ID */\n632             if (sol->VID_flags & GNRC_RPL_DIS_SOLICITED_INFO_FLAG_D) {\n633                 if (memcmp(&sol->dodag_id, &inst->dodag.dodag_id, sizeof(ipv6_addr_t)) != 0) {\n634                     DEBUG(\"RPL: RPL SOLICITED INFO option, ignore DIS cause: DODAGID mismatch\\n\");\n635                     return false;\n636                 }\n637             }\n638             break;\n639         case (GNRC_RPL_OPT_TARGET):\n640             DEBUG(\"RPL: RPL TARGET DAO option parsed\\n\");\n641             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_TARGET;\n642\n643             gnrc_rpl_opt_target_t *target = (gnrc_rpl_opt_target_t *)opt;\n644             if (first_target == NULL) {\n645                 first_target = target;\n646             }\n647\n648             DEBUG(\"RPL: adding FT entry %s/%d\\n\",\n649                   ipv6_addr_to_str(addr_str, &(target->target), (unsigned)sizeof(addr_str)),\n650                   target->prefix_length);\n651\n652             gnrc_ipv6_nib_ft_del(&(target->target), target->prefix_length);\n653             gnrc_ipv6_nib_ft_add(&(target->target), target->prefix_length, src,\n654                                  dodag->iface,\n655                                  dodag->default_lifetime * dodag->lifetime_unit);\n656             break;\n657\n658         case (GNRC_RPL_OPT_TRANSIT):\n659             DEBUG(\"RPL: RPL TRANSIT INFO DAO option parsed\\n\");\n660             *included_opts |= ((uint32_t)1) << GNRC_RPL_OPT_TRANSIT;\n661             gnrc_rpl_opt_transit_t *transit = (gnrc_rpl_opt_transit_t *)opt;\n662             if (first_target == NULL) {\n663                 DEBUG(\"RPL: Encountered a RPL TRANSIT DAO option without \"\n664                       \"a preceding RPL TARGET DAO option\\n\");\n665                 break;\n666             }\n667\n668             do {\n669                 DEBUG(\"RPL: updating FT entry %s/%d\\n\",\n670                       ipv6_addr_to_str(addr_str, &(first_target->target), sizeof(addr_str)),\n671                       first_target->prefix_length);\n672\n673                 gnrc_ipv6_nib_ft_del(&(first_target->target),\n674                                      first_target->prefix_length);\n675                 gnrc_ipv6_nib_ft_add(&(first_target->target),\n676                                      first_target->prefix_length, src,\n677                                      dodag->iface,\n678                                      transit->path_lifetime * dodag->lifetime_unit);\n679\n680                 first_target = (gnrc_rpl_opt_target_t *)(((uint8_t *)(first_target)) +\n681                                                          sizeof(gnrc_rpl_opt_t) +\n682                                                          first_target->length);\n683             }while (first_target->type == GNRC_RPL_OPT_TARGET);\n684\n685             first_target = NULL;\n686             break;\n687\n688 #ifdef MODULE_GNRC_RPL_P2P\n689         case (GNRC_RPL_P2P_OPT_RDO):\n690             gnrc_rpl_p2p_rdo_parse((gnrc_rpl_p2p_opt_rdo_t *)opt, gnrc_rpl_p2p_ext_get(dodag));\n691             break;\n692 #endif\n693         }\n694         len_parsed += opt->length + sizeof(gnrc_rpl_opt_t);\n695         opt = (gnrc_rpl_opt_t *)(((uint8_t *)(opt + 1)) + opt->length);\n696     }\n697     return true;\n698 }\n",
        "ipv6_addr_set_aiid": "628 static inline void ipv6_addr_set_aiid(ipv6_addr_t *addr, uint8_t *iid)\n629 {\n630     memcpy(&addr->u64[1], iid, sizeof(addr->u64[1]));\n631 }\n",
        "_sec_to_ms": "501 static inline uint32_t _sec_to_ms(uint32_t sec)\n502 {\n503     if (sec == UINT32_MAX) {\n504         /* infinite stays infinite */\n505         return UINT32_MAX;\n506     }\n507     else if (sec > ((UINT32_MAX - 1) / MS_PER_SEC)) {\n508         /* truncate long intervals to largest possible value */\n509         return UINT32_MAX - 1;\n510     }\n511     else {\n512         return sec * MS_PER_SEC;\n513     }\n514 }\n"
    }
}