{
    "errors": {
        "_skip_hostname": [
            "_skip_hostname @ Line 80: pointer relation: pointer outside object bounds in bufpos",
            "_skip_hostname @ Line 89: pointer relation: pointer outside object bounds in bufpos + 2",
            "_skip_hostname @ Line 97: pointer relation: pointer outside object bounds in &bufpos[(signed int)res]"
        ],
        "dns_msg_parse_reply": [
            "dns_msg_parse_reply @ Line 148: dereference failure: pointer outside object bounds in hdr->qdcount",
            "dns_msg_parse_reply @ Line 158: dereference failure: pointer outside object bounds in hdr->ancount",
            "dns_msg_parse_reply @ Line 165: pointer relation: pointer outside object bounds in bufpos + (signed int)2u + (signed int)2u + (signed int)4u + (signed int)sizeof(uint16_t) /*2u*/",
            "dns_msg_parse_reply @ Line 180: pointer relation: pointer outside object bounds in bufpos + (signed int)rdlen"
        ]
    },
    "unit_proof": "30 void harness(void)\n31 {\n32\n33     size_t len;\n34\n35\n36\n37\n38     uint8_t* buf = malloc(len);\n39     __CPROVER_assume(buf != NULL);\n40\n41     int family;\n42\n43     __CPROVER_assume(family == AF_UNSPEC || family == AF_INET || family == AF_INET6);\n44\n45\n46\n47\n48     uint8_t size;\n49     __CPROVER_assume(size >= 16);\n50     uint8_t *addr_out = malloc(size);\n51     __CPROVER_assume(addr_out != NULL);\n52\n53     uint32_t ttl;\n54     dns_msg_parse_reply(buf, len, family, addr_out, &ttl);\n55 }\n",
    "relevent_funcs": {
        "dns_msg_parse_reply": "140 int dns_msg_parse_reply(const uint8_t *buf, size_t len, int family,\n141                         void *addr_out, uint32_t *ttl)\n142 {\n143     const uint8_t *buflim = buf + len;\n144     const dns_hdr_t *hdr = (dns_hdr_t *)buf;\n145     const uint8_t *bufpos = buf + sizeof(*hdr);\n146\n147     /* skip all queries that are part of the reply */\n148     for (unsigned n = 0; n < ntohs(hdr->qdcount); n++) {\n149         ssize_t tmp = _skip_hostname(buf, len, bufpos);\n150         if (tmp < 0) {\n151             return tmp;\n152         }\n153         bufpos += tmp;\n154         /* skip type and class of query */\n155         bufpos += (RR_TYPE_LENGTH + RR_CLASS_LENGTH);\n156     }\n157\n158     for (unsigned n = 0; n < ntohs(hdr->ancount); n++) {\n159         ssize_t tmp = _skip_hostname(buf, len, bufpos);\n160         if (tmp < 0) {\n161             return tmp;\n162         }\n163         bufpos += tmp;\n164         if ((bufpos + RR_TYPE_LENGTH + RR_CLASS_LENGTH +\n165              RR_TTL_LENGTH + sizeof(uint16_t)) >= buflim) {\n166             DEBUG(\"dns_msg: record beyond buf limit\");\n167             return -EBADMSG;\n168         }\n169         uint16_t _type = ntohs(_get_short(bufpos));\n170         bufpos += RR_TYPE_LENGTH;\n171         uint16_t class = ntohs(_get_short(bufpos));\n172         bufpos += RR_CLASS_LENGTH;\n173         if (ttl) {\n174             *ttl = byteorder_bebuftohl(bufpos);\n175         }\n176         bufpos += RR_TTL_LENGTH;\n177\n178         unsigned rdlen = ntohs(_get_short(bufpos));\n179         bufpos += RR_RDLENGTH_LENGTH;\n180         if ((bufpos + rdlen) > buflim) {\n181             return -EBADMSG;\n182         }\n183\n184         DEBUG(\"dns_msg: type: %u, class: %u, len: %u\\n\", _type, class, rdlen);\n185\n186         /* skip unwanted answers */\n187         if ((class != DNS_CLASS_IN) ||\n188                 ((_type == DNS_TYPE_A) && (family == AF_INET6)) ||\n189                 ((_type == DNS_TYPE_AAAA) && (family == AF_INET)) ||\n190                 ! ((_type == DNS_TYPE_A) || ((_type == DNS_TYPE_AAAA))\n191                     )) {\n192             if (rdlen > len) {\n193                 /* buffer wraps around memory space */\n194                 return -EBADMSG;\n195             }\n196             bufpos += rdlen;\n197             /* other out-of-bound is checked in `_skip_hostname()` at start of\n198              * loop */\n199             continue;\n200         }\n201         if (((rdlen != INADDRSZ)  && (family == AF_INET))  ||\n202             ((rdlen != IN6ADDRSZ) && (family == AF_INET6)) ||\n203             ((rdlen != IN6ADDRSZ) && (rdlen != INADDRSZ) &&\n204              (family == AF_UNSPEC))) {\n205             return -EBADMSG;\n206         }\n207\n208         memcpy(addr_out, bufpos, rdlen);\n209         return rdlen;\n210     }\n211\n212     return -EBADMSG;\n213 }\n",
        "ntohs": "372 static inline uint16_t ntohs(uint16_t v);\n",
        "_skip_hostname": "74 static ssize_t _skip_hostname(const uint8_t *buf, size_t len,\n75                               const uint8_t *bufpos)\n76 {\n77     const uint8_t *buflim = buf + len;\n78     unsigned res = 0;\n79\n80     if (bufpos >= buflim) {\n81         /* out-of-bound */\n82         DEBUG(\"dns_msg: bufpos is out of bounds\\n\");\n83         return -EBADMSG;\n84     }\n85\n86     /* handle DNS Message Compression */\n87     if (*bufpos & 0xc0) {\n88         DEBUG(\"dns_msg: hostname is compressed\\n\");\n89         if ((bufpos + 2) >= buflim) {\n90             return -EBADMSG;\n91         }\n92         return 2;\n93     }\n94\n95     while (bufpos[res]) {\n96         res += bufpos[res] + 1;\n97         if ((&bufpos[res]) >= buflim) {\n98             /* out-of-bound */\n99             DEBUG(\"dns_msg: hostname out-of-bounds\\n\");\n100             return -EBADMSG;\n101         }\n102     }\n103     return res + 1;\n104 }\n",
        "_get_short": "67 static unsigned _get_short(const uint8_t *buf)\n68 {\n69     uint16_t _tmp;\n70     memcpy(&_tmp, buf, 2);\n71     return _tmp;\n72 }\n",
        "byteorder_bebuftohl": "291 static inline uint32_t byteorder_bebuftohl(const uint8_t *buf);\n",
        "unaligned_get_u32": "81 static inline uint32_t unaligned_get_u32(const void *ptr)\n82 {\n83     const uint32_una_t *tmp = (const uint32_una_t *)ptr;\n84     return tmp->val;\n85 }\n"
    }
}