{
    "errors": {
        "strlen": [
            "strlen @ Line 18: dereference failure: pointer outside object bounds in s[(signed int)len]"
        ]
    },
    "unit_proof": "35 void harness(void)\n36 {\n37     uint16_t port;\n38\n39     size_t str_size;\n40\n41\n42     char* id = malloc(str_size);\n43     __CPROVER_assume(id != NULL);\n44\n45\n46     subs = malloc(sizeof(emcute_sub_t));\n47     if(subs != NULL) {\n48         subs -> next = NULL;\n49         subs -> cb = emcute_callback;\n50     }\n51\n52\n53     emcute_run(port, id);\n54 }\n",
    "relevent_funcs": {
        "emcute_run": "499 void emcute_run(uint16_t port, const char *id)\n500 {\n501     assert(strlen(id) >= MQTTSN_CLI_ID_MINLEN &&\n502            strlen(id) <= MQTTSN_CLI_ID_MAXLEN);\n503\n504     sock_udp_ep_t local = SOCK_IPV6_EP_ANY;\n505     sock_udp_ep_t remote;\n506     local.port = port;\n507     cli_id = id;\n508     timer.callback = time_evt;\n509     timer.arg = NULL;\n510     mutex_init(&txlock);\n511\n512     if (sock_udp_create(&sock, &local, NULL, 0) < 0) {\n513         LOG_ERROR(\"[emcute] unable to open UDP socket on port %i\\n\", (int)port);\n514         return;\n515     }\n516\n517     uint32_t start = xtimer_now_usec();\n518     uint32_t t_out = (CONFIG_EMCUTE_KEEPALIVE * US_PER_SEC);\n519\n520     while (1) {\n521         ssize_t len = sock_udp_recv(&sock, rbuf, sizeof(rbuf), t_out, &remote);\n522\n523         if ((len < 0) && (len != -ETIMEDOUT)) {\n524             LOG_ERROR(\"[emcute] error while receiving UDP packet\\n\");\n525             continue;\n526         }\n527\n528         if (len >= 2) {\n529             /* handle the packet */\n530             uint16_t pkt_len;\n531             /* catch invalid length field */\n532             if ((len == 2) && (rbuf[0] == 0x01)) {\n533                 continue;\n534             }\n535             /* parse length field */\n536             size_t pos = get_len(rbuf, &pkt_len);\n537             /* verify length to prevent overflows */\n538             if (((size_t)pkt_len > (size_t)len) || (pos >= (size_t)len)) {\n539                 continue;\n540             }\n541             /* get packet type */\n542             uint8_t type = rbuf[pos];\n543\n544             switch (type) {\n545                 case CONNACK:       on_ack(type, 0, 2, 0);              break;\n546                 case WILLTOPICREQ:  on_ack(type, 0, 0, 0);              break;\n547                 case WILLMSGREQ:    on_ack(type, 0, 0, 0);              break;\n548                 case REGACK:        on_ack(type, 4, 6, 2);              break;\n549                 case PUBLISH:       on_publish((size_t)pkt_len, pos);   break;\n550                 case PUBACK:        on_ack(type, 4, 6, 0);              break;\n551                 case SUBACK:        on_ack(type, 5, 7, 3);              break;\n552                 case UNSUBACK:      on_ack(type, 2, 0, 0);              break;\n553                 case PINGREQ:       on_pingreq(&remote);                break;\n554                 case PINGRESP:      on_pingresp();                      break;\n555                 case DISCONNECT:    on_disconnect();                    break;\n556                 case WILLTOPICRESP: on_ack(type, 0, 0, 0);              break;\n557                 case WILLMSGRESP:   on_ack(type, 0, 0, 0);              break;\n558                 default:\n559                     LOG_DEBUG(\"[emcute] received unexpected type [%s]\\n\",\n560                               emcute_type_str(type));\n561             }\n562         }\n563\n564         uint32_t now = xtimer_now_usec();\n565         if ((now - start) >= (CONFIG_EMCUTE_KEEPALIVE * US_PER_SEC)) {\n566             send_ping();\n567             start = now;\n568             t_out = (CONFIG_EMCUTE_KEEPALIVE * US_PER_SEC);\n569         }\n570         else {\n571             t_out = (CONFIG_EMCUTE_KEEPALIVE * US_PER_SEC) - (now - start);\n572         }\n573     }\n574 }\n"
    }
}