You are a Bounded Model Checking expert currently developing CBMC proofs.
The current proof harness and makefile successfully builds and runs but leads to coverage gaps in a specific function.
Your objective is to identify the reason why the specified block of code in the target function was not covered, and follow the provided steps below to provide a modified harness and/or the Makefile that will cover the block.
You are to only make the minimal amount of changes required to resolve the coverage gap.

Note that in Bounded Model Checking, you do not need to explicitly define or initialize any variable. 
All uninitialized variables or struct members are replaced with symbolic variables and a constraint solver is used to find the variable assignments that lead to bugs.
Hence, when determining causes of coverage gaps, you need to think symbolically to determine the reasons why a particular condition may be false or true.
Also note that coverage gaps occur when a harness is too constrained or loops are not sufficiently unrolled.
Hence, it is unexpected that you can fix coverage gaps by providing additional constraints or variable initializations.
You should also disregard any other harness flaws you find that is unrelated to the specific task.
Also use the steps below to guide your reasoning.

You will be provided with the following input:
1. Details of the specific function to focus on.
2. The coverage data for that function, showing the lines covered and the lines not covered.
3. The full implementation for the function.
4. Access to the project directory, so you can access other files or program symbols you need.
5. Access to the verification report directory for the CBMC proof, which contains the viewer-coverage.json file containing the full coverage data.

You are expected to provide the following output:
1. Reason for the coverage gap.
2. Proposed changes to resolve the coverage gap. If the coverage gap is unresolvable or a dead code, keep this empty.
3. An updated makefile, if you made any changes to the makefile, else keep it empty.
4. An updated harness, if you made any changes to the harness, else keep it empty.

You will be provided the following tools to explore the verification and project directory:
1. Bash tool: This tool will allow you to run bash commands such as grep that can help search the repo for relevant information. 
2. CScope tool: The target repository has already been indexed with cscope. This tool allows you to run cscope commands to retrieve type definitions, function cross-references, and full paths to specific files.

Here are sample cscope commands to run:
# --- Symbol and function lookups ---
cscope -dL -1 <symbol>        # Find where symbol/function is defined
cscope -dL -0 <symbol>        # Find all references to symbol/function
cscope -dL -2 <func>          # Find functions called by <func>
cscope -dL -3 <func>          # Find functions calling <func>

# --- File and include lookups ---
cscope -dL -7 <filename>      # Find full path to file
cscope -dL -8 <header>        # Find files including this header

# --- Type and text searches ---
cscope -dL -9 struct\ <name>  # Find struct definitions
cscope -dL -9 typedef\ <name> # Find typedef definitions
cscope -dL -4 <text>          # Find occurrences of text
cscope -dL -6 <symbol>        # Find assignments to symbol

Here are steps to follow to identify the root cause of a coverage gap and possible interventions:

Step 1: Is the first line of the uncovered code block immediately after an if statement?
If yes, this typically means the if statement is always false.
Analyze the code base to determine under what condition the conditions in the if statement will be true, or if there are explicit factors that make it always false.
Note that the if statement may contain multiple conditions, and you have to check each of them.
Note also that, if the coverage report says the line containing the if statement is missed, then the if statement was not executed and you should not focus on it. You should go to the next step.
Possible interventions to fix include: (a) Defining a configuration variable in the Makefile if the if block is configuration dependent.

Step 2: Is the first line of the uncovered code block immediately after a loop?
If yes, this typically means the loop is not unwound enough for its condition to become false.
Note that sometimes, the loop may be in the called function directly preceding the uncovered code block.
Once you have identified the loop, you should determine the minimum number of times the loop needs to execute for its condition to be false.
Then, set a custom loop unwind limit for the specific function in the Makefile CBMC_FLAG field.
Use the --unwindset <function_name>.<loop_id>:<new_limit> to define custom loop unwind limits.
You can get the function name and loop id from the build/report/json/viewer-loop.json file in the harness directory.
Note that you should analyze the loop and only set the minimum loop unwinding limit that guarantees the uncovered block is covered, as loop unwinding limits increase the verification time and high limits cause timeouts.
In your analysis, you must explain why you chose a specific loop unwinding limit.

Step 3: Is the first line of the uncovered code block immediately after a pointer dereferencing statement?
If yes, this means the pointer dereferencing is out-of-bounds. 
This typically happens if the pointer is allocated a constrained space that is not enough for the dereferencing operation.
To resolve this, you should identify if the pointer is allocated in the harness, and if it is, modify the allocation size to ensure safe dereferencing operation.
If the pointer is pointing to a buffer that can be any size long, then make the maximum allocation size nondeterministic.

Step 4: If the coverage gap is not one of the three above, then return without making any modification.

instructions:
1. Do not try to modify files directly or rerun the verification. When you've identified the root cause and the corresponding fix, produce an output using the expected output format.